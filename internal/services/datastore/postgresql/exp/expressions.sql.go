// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: expressions.sql

package expstore

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createExpression = `-- name: CreateExpression :one
INSERT INTO expressions (expression_id, expression, username, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
    RETURNING row_id, expression_id, expression, username, created_at, updated_at
`

type CreateExpressionParams struct {
	ExpressionID uuid.UUID `json:"expressionID"`
	Expression   string    `json:"expression"`
	Username     string    `json:"username"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
}

func (q *Queries) CreateExpression(ctx context.Context, arg CreateExpressionParams) (Expressions, error) {
	row := q.queryRow(ctx, q.createExpressionStmt, createExpression,
		arg.ExpressionID,
		arg.Expression,
		arg.Username,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Expressions
	err := row.Scan(
		&i.RowID,
		&i.ExpressionID,
		&i.Expression,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpressionByID = `-- name: DeleteExpressionByID :exec
DELETE
FROM expressions
WHERE expression_id = $1
`

func (q *Queries) DeleteExpressionByID(ctx context.Context, expressionID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteExpressionByIDStmt, deleteExpressionByID, expressionID)
	return err
}

const getExpressionByID = `-- name: GetExpressionByID :one
SELECT row_id, expression_id, expression, username, created_at, updated_at
FROM expressions
WHERE expression_id = $1
    LIMIT 1
`

func (q *Queries) GetExpressionByID(ctx context.Context, expressionID uuid.UUID) (Expressions, error) {
	row := q.queryRow(ctx, q.getExpressionByIDStmt, getExpressionByID, expressionID)
	var i Expressions
	err := row.Scan(
		&i.RowID,
		&i.ExpressionID,
		&i.Expression,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listExpressions = `-- name: ListExpressions :many
SELECT row_id, expression_id, expression, username, created_at, updated_at
FROM expressions
ORDER BY row_id
`

func (q *Queries) ListExpressions(ctx context.Context) ([]Expressions, error) {
	rows, err := q.query(ctx, q.listExpressionsStmt, listExpressions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Expressions{}
	for rows.Next() {
		var i Expressions
		if err := rows.Scan(
			&i.RowID,
			&i.ExpressionID,
			&i.Expression,
			&i.Username,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaginatedExpressions = `-- name: ListPaginatedExpressions :many
SELECT row_id, expression_id, expression, username, created_at, updated_at
FROM expressions
ORDER BY row_id
    LIMIT $1 OFFSET $2
`

type ListPaginatedExpressionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPaginatedExpressions(ctx context.Context, arg ListPaginatedExpressionsParams) ([]Expressions, error) {
	rows, err := q.query(ctx, q.listPaginatedExpressionsStmt, listPaginatedExpressions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Expressions{}
	for rows.Next() {
		var i Expressions
		if err := rows.Scan(
			&i.RowID,
			&i.ExpressionID,
			&i.Expression,
			&i.Username,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpression = `-- name: UpdateExpression :one
UPDATE expressions
SET (expression, updated_at) = ($2, $3)
WHERE expression_id = $1
    RETURNING row_id, expression_id, expression, username, created_at, updated_at
`

type UpdateExpressionParams struct {
	ExpressionID uuid.UUID `json:"expressionID"`
	Expression   string    `json:"expression"`
	UpdatedAt    time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateExpression(ctx context.Context, arg UpdateExpressionParams) (Expressions, error) {
	row := q.queryRow(ctx, q.updateExpressionStmt, updateExpression, arg.ExpressionID, arg.Expression, arg.UpdatedAt)
	var i Expressions
	err := row.Scan(
		&i.RowID,
		&i.ExpressionID,
		&i.Expression,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
